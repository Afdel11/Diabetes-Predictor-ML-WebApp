# -*- coding: utf-8 -*-
"""Livedata_clustering_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B7Ok7T9TVGqs40zvLF-ogo-o3U_q7oku

### <font color = "gold"> Importer les librairies requises
"""

# Importer les packages
import pandas as pd
import numpy as np

# # Supprimer les warnings
#  import warnings
#  warnings.filterwarnings('ignore')

# from google.colab import drive
# drive.mount('/content/drive')

"""### <font color = "gold"> Importer et lire les données"""

# Importer les données
df = pd.read_csv('/content/drive/MyDrive/MES COURS/L3/MACHINE LEARNING/ML Final Projet/Live_20210128.csv')

# Afficher les données
df.head()

# Dimension des données
df.shape

# Infos des données
df.info()

# Décrire les données
df.describe()

# Renommer les index
df.index.name = 'index'
df.head()

"""### <font color = "gold"> Nettoyage des données"""

# # Convertir 'status_published' en format datetime
# df["status_published"] = pd.to_datetime(df["status_published"], errors="coerce")

# # # Séparer en deux colonnes 'date' et 'heure'


# # Extraire des caractéristiques
# df['year'] = df['status_published'].dt.year
# df['month'] = df['status_published'].dt.month
# df['day'] = df['status_published'].dt.day
# df['hour'] = df['status_published'].dt.hour
# df['minute'] = df['status_published'].dt.minute
# df['day_of_week'] = df['status_published'].dt.weekday
# df.head()

#supprimer les colones vides Column1	Column2	Column3	Column4
df = df.drop(['Column1', 'Column2', 'Column3', 'Column4', 'status_id','status_published'], axis=1)
df.head(100)

# selectionner les differentes valaures de la colone status_type
df['status_type'].unique()

df.head()

# Encoder la variable 'status_type'
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
df['status_type'] = le.fit_transform(df['status_type'])
df.head()

# normalisation des donnees pour le cluster
# from sklearn.preprocessing import MinMaxScaler
# scaler = MinMaxScaler()
# df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns)
# df.head()

# Matrice des données
df.values

x = df.values
x

"""#### <font color = "gold"> Appliquer une ACP"""

from sklearn.decomposition import PCA

#Instantier le modèle PCA avec n_components = 3
pca = PCA(n_components = 3)

# Entrainer le modèle
pca.fit(x) # Use the modified x here

# Matrice des 2 composantes
features_pca = pca.fit_transform(x) # Use the modified x here

# Dataframe
nwe_df = pd.DataFrame(features_pca, columns = ['PCA1', 'PCA2','PCA3'])
nwe_df.head()

# Part de variance des 2 composantes
round(sum(pca.explained_variance_ratio_)*100, 2)

"""### <font color = "gold"> Kmeans"""

# Importer KMeans
from sklearn.cluster import KMeans

# liste des inerties
Inertia = []
for n_clusters in range(2,11):
  # appliquer un kmeans pour un k donné
  kmeans = KMeans(n_clusters = n_clusters, init = 'random', max_iter = 500)
  # entrainement
  kmeans.fit(x)
  # rajouter inertie intra de la partition pour un k donnée au niveau de liste Inertia
  Inertia.append(kmeans.inertia_)

# Afficher le plot Inertia
import matplotlib.pyplot as plt
plt.plot(range(2,11), Inertia)
plt.xticks(range(2,11))
plt.xlabel('Nombre de clusters')
plt.ylabel('Inertia intra classe de la partition')
plt.show()

"""#### <font color = "bisque"> Appliquer Kmeans en utilisant le k optimal"""

# Initier le modèle
kmeans_model = KMeans(n_clusters = 4, init = 'random', max_iter = 500)
# Entrainer le modèle
kmeans_model.fit(x)

"""#### <font color = "bisque"> Prédiction la partition"""

# Prediction de la partition(l'ensemble des classes) de X
par = kmeans_model.predict(x)
par

# Nombre d'observations dans chaque classe
val = pd.Series(par).value_counts()
val

# Diagramme en barre du nombre d'observations dans chaque
import plotly.express as px
fig = px.bar(x = val.index, y = val.values, color = val.index.astype(str), text_auto = True)
fig.show()

"""#### <font color = "bisque"> Visualiser les classes prédictes par Kmeans"""

# visualisation en 3 dimension
fig = px.scatter_3d(nwe_df, x = 'PCA1', y = 'PCA2', z = 'PCA3', color = par.astype(str))
fig.show()

# Visualiser les classes suivant les deux composantes en utilisant plotly.express
fig = px.scatter(data_frame =nwe_df, x = 'PCA1', y = 'PCA2', color = par.astype(str))
fig.show()

"""<font color = "bisque">Indice de silhouette value de la partition du Kmeans"""

# Importer silhouette score
from sklearn.metrics import silhouette_score
# Indice de Silhouette value
sil_KM = round(silhouette_score(x, par),2)
sil_KM

# Les graines de chaque classes
Clusters = []
for i in range(6):
    cluster = df.index[par==i]
    Clusters.append(cluster)

# Afficher les graines de la classe 0
Clusters

# telecharger les donnees reeles d'un cluster en particulier
Cluster = input( 'veuiller entrer le chiffre du cluster : ')
df.loc[Clusters[int(Cluster)]]